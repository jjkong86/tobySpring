## 1장 오브젝트와 의존관계

**초난감 UserDao 클래스의 문제, 57p**

 * 반복되는 소스(connection, PreparedStatement 바인딩)
 * 쿼리 분리
 * 반복되는 객체의 생성과 소멸(재사용성 필요)
 * 객체의 close 보장하지 못함

**커넥션과 핵심로직의 분리**

> 리팩토링 : 기존의 코드를 외부의 동작방식에는 변화 없이 내부 구조를 변경해서 재구성하는 작업 또는 기술

---

 **1. getConnection을 메소드로 분리(메소드 추출 기법) : 63p 1-4예제**
 
 **2. 상속을 통한 확장 : getConnection을 추상 메소드로 분리(추상 클래스가 됨)**

  * 구현체에서 getconnection을 관리
  * 서브클래스에서 구체적인 오브젝트 생성 방법을 결정 : 템플릿 메소드 패턴(변하지 않는 기능은 슈퍼클래스에 만들어두고 자주 변경되며 확장할 기능은 서브클래스에서 만들도록 함)
  * 서브클래스를 통해서 만들어진 오브젝트의 종류가 달라질 수 있게 하는 것을 목적 : 팩토리 메소드 패턴
  * 문제점
   - 1. 자바에서는 다중 상속을 지원하지 않기 때문에 상속을 사용했다는 그 자체
   - 2. 상속을 통한 상하위 클래스의 관계이기에 밀접함 -> 두 가지 다른 관심사에 대해 밀접한 결합을 허용, 슈퍼클래스가 변경되면 서브 클래스도 변경이 필요함
   - 3. 다른 DAO 클래스에 적용이 안됨
     -> 변화의 성격이 다른 것을 분리해서 독립적으로 변경이 안됨

 **3. 클래스의 분리**
  - getConnection을 별도의 클래스로 분리
  - 특정 클래스를 명시해서 생성 해야 하기 때문에 종속됨
  
 **4. 인터페이스의 도입 : 81p 1-11**
  - 두 개의 클래스가 서로 긴밀하게 연결되어 잇지 않도록 중간에 추상적인 느슨한 연결고리를 만들어줌 -> 관계설정 책임의 분리
  - 클라이언트에서 만들어준 객체를 사용(런타임 시점에서), 생성자나 setter 방식을 통해서
  - 구현체(오브젝트)를 인터페이스 타입으로 받아서 사용 -> 다형성의 특징
  - 개방 패쇄 원칙이 적용됨
   1. DB 연결 기능을 확장 하는데는 열려있음
   2. 핵심 기능(insert, get)은 DB에 영향을 받지 않음
   3. 높은 응집도와 낮은 결합도를 의미함

제어의 역전(Ioc)
 - 오브젝트가 자산이 사용할 오브젝트를 스스로 선택, 생성을 하지 않고 주입되는 오브젝트를 사용
 - 템플릿 메소드

스프링의 IoC
 - 스프링에서는 스프링이 제어권을 가지고 직접 만들고 관계를 부여하는 오브젝트를 빈이라고 함(IoC 방식으로 관리하는 오브젝트)
 - 빈은 스프링 컨테이너가 생성과 관계설정, 사용 등을 제어해주는 제어의 역전이 적용된 오브젝트를 가리킴
 - 애플리케이션 컨텍스트, 스프링 컨테이너, Ioc 컨테이너, 빈 팩토리
 
어플리케이션 컨텍스트
 - 오브젝트 설정을 담당하는 클래스라고 인식할 수 있도록 @Configuration 어노테이션을 추가하고 필요한 메소드에 @Bean 어노테이션을 추가하면 설정정보 세팅이 다된것
 - 설정 정보를 가져와서 빈의 이름(기본은 메소드 이름)으로 객체를 가져와서 사용할 수 있음, p99 그림 1-9
 - 동작 방식
  1. @Bean이 붙은 메소드의 이름을 가져와 빈 목록을 만들어 둠
  2. 클라이언트가 getBean() 메소드를 호출하면 목록에서 요청한 이름을 찾음
  3. 있으면 빈을 생성하는 메소드를 호출해서 오브젝트를 생성시킨 후 클라이언트에게 돌려줌
 - 장점
  1. 클라이언트는 구체적인 팩토리 클래스를 알 필요가 없다 -> 컨테이너가 목록을 직접 관리
  2. 애플리케이션 컨텍스트는 종합 IoC 서비스를 제공해준다 -> 관계설정 뿐만 아니라 오브젝트가 만들어지는 방식, 시점과 전략을 다르게 가져갈 수 있고 등등
  3. 애플리케이션 컨텍스트는 빈을 검색하는 다양한 방법을 제공 -> 이름뿐만 아니라 타입, 특별 어노테이션으로 검색 가능
  
싱글톤 레지스트리와 오브젝트 스코프
 - 스프링은 여러 번에 걸쳐 빈을 요청하더라도 동일한 오브젝트를 돌려줌 -> 싱글톤(한 개의 오브젝트만 만들어서 사용하는 것), 106p 1-22
 - 싱글톤인 이유 : 높은 성능이 요구되는 상황에서 요청마다 객체를 생성하고 소멸시키면 서버에 많은 부하가 걸리기 때문
 - 싱글톤의 문제점
  1. private 생성자를 갖고 있기 때문에 상속 불가능 (자식 객체에서 super()를 호출 하여 부모 객체 생성 -> 자식 객체 생성하기 때문)
  2. 테스트하기가 힘들다 -> 테스트를 위해 다른 객체로 갈아 끼우는것이 불가능
  3. 싱글톤은 전역 상태를 만듬 -> method area영역에 저장 되기 때문에 GC의 대상이 아님, 메모리가 오염됨, 아무 객체나 접근이 가능한데 객체지향 프로그래밍에서는 권장 하는 방법이 아님
  
스프링의 싱글톤 레지스트리
 - 스프링이 직접 싱글톤 형태의 오브젝트를 만들고 관리
 - static과 private 생성자를 사용하지 앟아도 되기 때문에 단점 보안
 - 멀티스레드 환경에서는 thread safe 하도록 무상태 방식으로 만들어져야함, 파라미터와 로컬 변수, 리턴 값 등을 활용
 - 110p, 1-23
 - 빈의 생성, 존재, 적용되는 범위를 스코프라고 함
 - 옵션 : 싱글톤, 프로토 타입, request, session

의존관계 주입(DI)
 - 두 개의 클래스 또는 모듈이 의존관계에 있다고 말할 때는 항상 방향성을 부여해 줘야함(A -> B)
 - 의존한다는 건 의존대상, B가 벼하면 A에 영향을 미침
 - 인터페이스에 대해서만 의존관계를 만들어두면 결합도를 낮출 수 있음
 - 의존관계 주입은 의존 오브젝트와 클라이언트 오브젝트를 런타임 시에 연결해주는 작업
 - 의존관계 주입의 조건
  1. 클래스 모델이나 코드에는 런타임 시점의 의존관계가 드러나지 않는다. 그러기 위해서는 인터페이스에만 의존하고 있어야함
  2. 런타임 시점의 의존관계는 컨테이너나 팩토리 같은 제3의 존재가 결정, 레퍼런스는 외부에서 주입해줌 -> 스프링 컨테이너
	ex) UserDao -> getConnection는 인터페이스를 바라보고 제의 존재에게 의존 오브젝트를 받아서 사용(생성자나 setter를 통해서)
	
의존관계 검색과 주입, 118p
 - 런타임 시 의존관계를 맺을 오브젝트를 결정하는 것과 오브젝트의 생성작업은 외부 컨테이너에게 IoC로 맞김(DI와 같음)
 - 가져올때는 스스로 컨테이너에게 오브젝트를 요청함
 - DI 방식을 더 권장 하지만 어플리케이션의 기동시점에서 적어도 한 번은 의존관계 검색 방식을 사용해 오브젝트를 가져와야함
 - ex) main()메소드는 DI를 이용해서 오브젝트를 주입 방법이 없기 때문에 검색 방식을 사용해야함
 - 검색 방식에서 검색 하는 오브젝트는 자신이 스프링 빈이 아니어도됨, 그러나 주입은 관계를 갖는 오브젝트는 빈이어야함
 
의존성 주입 방법
 1. 수정자 메소드를 이용한 주입
  - xml을 사용하는 경우 자바빈 규약에 따라 사용함
 2. 생성자 방식
  - 여러개를 받을 수 있음, 의도적으로 null을 넘기지 않는 이상 null safe, 순환참조 방지, lombok을 이용하면 편리함
