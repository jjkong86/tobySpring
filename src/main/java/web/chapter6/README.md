## 6장 AOP

 **트랜잭션 코드의 분리(402p 6-1)**

 * 비지니스 로직 코드를 사이에 두고 트랜잭션 시작과 종료를 담당하는 코드가 앞뒤에 위치
 * 성격도 다르고 주고받는 것도 없는, 완벽하게 독립적인 코드
 * UserService에서 완벽하게 분리 하는게 목적 -> DI를 적용해서
 * 기존 UserService를 인터페이스로 만들고 관계를 유연하고 확장 가능하게 만듬
 
**분리된 트랜잭션 기능**
 * UserService를 구현하는 UserServiceImpl과 UserServiceTx로 분리
 * 406p 6-4, 408p 6-6

**트랜잭션 경계설정 코드 분리의 장점**
 * 비지니스 로직과 관계 없는 코드(트랜잭션)를 신경쓸 필요가 없음(프록시를 이용)
 * 비지니스 로직에 대한 테스트를 손쉽게 할 수 있음(가능한 한 작은 단위로 쪼개는게 좋음)

**고립된 단위 테스트**
 * UserService가 동작하려면 여러 오브젝트와 관계를 갖고 있음(414p, 6-5)
 * 이런 경우의 테스트는 준비하기 힘들고, 환경에 따라 종속적이며, 수행속도가 느림
 * 비지니스 로직의 테스트를 위해서 테스트 대상 오브젝트를 고립시킬 필요가 있음
 * 417p, 6-10

---

###AOP 정리

**조건**
> UserService의 userUpgrade 메소드에서는 모든 유저의 레벨을 조건에 맞게 업그레이드 시킨다고 가정   
> 비지니스 로직 코드를 사이에 두고 트랜잭션 시작과 종료를 담당하는 코드가 앞뒤에 위치

---

**1. 프록시를 이용한 데코레이터 패턴 활용 **
  * 인터페이스를 이용해 구현 클래스를 클라이언트에 노출하지 않고 런타임 시에 DI를 적용(전략패턴)해서 직접 결합을 막고 유연한 확장이 가능하게 함
  * 또한 구현 클래스를 바꿔가면서 사용 가능하기 때문에 테스트 용이함
  * 부가 기능을 런타임 시 다이나믹하게 부여해주기 때문에 코드 레벨에선 알 수 없음
  *  **문제점 **
  
	1. 타깃의 인터페이스를 구현하고 위임하는 코드를 작성하기가 번거로움
	2. 부가기능 코드가 중복될 가능성이 많음
  
**2. 다이나믹 프록시 **
  * 다이나믹 프록시 오브젝트는 클라이언트의 모든 요청을 리플렉션 정보로 변환해서 InvocationHandler 구현 오브젝트의 invoke() 메소드로 넘김
  * 타깃 인터페이스의 모든 메소드 요청이 하나의 메소드로 집중되기 때문에 중복되는 기능을 제공
  * 스프링 빈으로 만들기 위해서 팩토리 빈을 이용
  * 한번 부가기능을 가진 프록시를 생성하는 팩토리 빈을 만들어두면 타깃의 타입에 상관없이 재사용 할 수 있음
  *  **문제점**
  
	1. 한 번에 여러 개의 클래스에 공통적인 부가기능을 제공이 안됨
	2. 하나의 타깃에 여러 개의 부가기능을 적용하기 힘듬(빈 설정이 필요 수 만큼 늘어남)
	
**3. 스프링의 프록시 팩토리 빈 **
  * 로직을 분리하고 부가기능은 Metodinterceptor 인터페이스를 구현해서 만듬
  * addAdvice() 메소드를 사용해서 여러 개의 methdInterceptor를 추가 가능(어드바이스 : 부가기능을 담은 오브젝트)
  * 포인트컷(메소드 선정 알고리즘)을 사용하면 advice와 pointcut을 묶어서 advisor에 등록해야함 : 여러개의 어드바이저가 등록 될 수 있는데 구분이 필요함
  * **타깃 오브젝트마다 거의 비슷한 내용의 ProxyFactoryBean 빈 설정정보를 추가해줘야 하는 문제가 있음 -> DefaultAdvisorAutoProxyCreator(빈 후처리기)를 빈으로 등록하면 타깃 오브젝트에 자동으로 프록시가 적용됨**
  
**4. AOP란 **
  * 
  * AspectJ는 타깃 오브젝트를 뜯어고쳐서 기능을 직접 넣어주는 직접적인 방법을 사용, 컴파일된 클래스 파일이나 JVM에 로딩되는 시점을 가로채서 바이트코드를 조작, 유연, 강력, 하지만 번거로움